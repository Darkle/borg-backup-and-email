if !process.env.NODE_ENV: process.env.NODE_ENV = "production"
import path from 'path'
import os from 'os'
import { promisify } from 'util'
import { exec, execFileSync } from 'child_process'

import dateFormat from 'dateformat'
import notifier from 'node-notifier'
import mailgunjs from 'mailgun-js'
import pReduce from 'p-reduce'
import onExit from 'signal-exit'

require('dotenv').config({path: path.join(__dirname, '.env')})
import { create, prune } from './borg.config.json5'

pExec = promisify(exec)
date = dateFormat(new Date(), 'yyyy-mm-dd-HHMMss')
osHostname = os.hostname()
mailgun = mailgunjs({
  domain: process.env.MAILGUN_DOMAIN,
  apiKey: process.env.MAILGUN_PRIVATE_APIKEY
})
mailOptions = {
  from: 'Borg Backup <borg@localhost.dev>',
  to: process.env.DESTINATION_EMAIL,
}
borgCreateParams = [
  ...create.options,
  ...for elem exclude in create.excludes: [ `--exclude "${ exclude }"` ],
  `${ create.repository }::${ create.prefix || osHostname }-${ date }`,
  ...for elem folders in create.foldersToBackup: [ `"${ folders }"` ],
]
borgPruneParams = [
  ...prune.options,
  `--prefix ${ prune.prefix || osHostname }-`,
  `--keep-daily ${ prune.keepDaily }`,
  `--keep-weekly ${ prune.keepWeekly }`,
  `--keep-monthly ${ prune.keepMonthly }`,
  prune.repository
]
logType = create.log?.type

if logType === 'file': borgCreateParams.push(` >> "${ create.log.destination }" 2>&1`)

/*****
* Adding large maxBuffer in case of verbose logging and lotsa files.
*/
pReduce(
  [
    pExec(`borg create ${ borgCreateParams.join(' ') }`, {maxBuffer: Infinity})
    pExec(`borg prune ${ borgPruneParams.join(' ') }`, {maxBuffer: Infinity}),
  ],
  joinExecResultsMessages,
  ''
)
.catch(identity)
.then(notify)
.then(sendEmail)

/*****
* For some reason the success message arrives in stderr. Â¯\_(ãƒ„)_/Â¯
*/
joinExecResultsMessages(totalMessage, result, index) ->
  borgAction = if index === 0: 'BACKUP' else: 'PRUNE'
  return `${ totalMessage }\n BORG ${ borgAction } RESULTS: \n${ result.stderr }`

sendEmail(result) ->
  if logType !== 'email': return
  mailgun.messages().send(
    {
      ...mailOptions,
      subject: generateMessageTitle(result),
      ...generateMessageText(result)
    },
    err -> if err: console.error(err)
  )

notify(result) ->
  messageTitle = generateMessageTitle(result)
  if !isError(result): notifier.notify(messageTitle)
  else:
    notifier.notify({
      title: messageTitle,
      message: result?.message
    })
  result

generateMessageTitle(result) ->
  if isError(result): 'Borg Backup Encountered An Error ðŸ’©'
  else: 'Borg Backup Completed Successfully ðŸ˜Ž'

generateMessageText(result) ->
  if isError(result):
    return { html: `<pre> ${ JSON.stringify(result) } </pre>` }
  else:
    { text: result }

isError(err) -> err instanceof Error
identity(param) -> param

onExit(() => {
  execFileSync('borg', ['break-lock', create.repository])
})

process.on('unhandledRejection', bailOnFatalError)
process.on('uncaughtException', bailOnFatalError)

bailOnFatalError(err):void ->
  console.error(err)
  process.exit(1)
